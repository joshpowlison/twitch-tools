<!-- https://twitch.tv/joshpowlison -->
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"></meta>
	<title>Heckle by JoshPowlison</title>
	
	<!-- Core Script -->
	<style>
		#frame-holder{
			top:0;
			left:0;
			width:100%;
			height:100%;
			position:fixed;
		}
		
		#frame-holder > img{
			position			: absolute;
			height				: 100%;
			width				: 100%;
			object-fit			: contain;
			animation			: animation 10s linear forwards;
		}
	</style>
</head>
<body>

<script src="../core/main.js"></script>
<div id="frame-holder"></div>
<script>
'use strict';

var TRIGGERS				= null;
var hecklesLastUseUser		= [];
var hecklesLastUseGlobal	= [];

const AUDIO_CONTEXT			= new AudioContext();

function loadTriggers(){
	// Load triggers after loading the required keys
	var requestTriggers = new XMLHttpRequest();
	requestTriggers.addEventListener('load', function(e){
		TRIGGERS = JSON.parse(this.responseText);
		console.log('Updated triggers');
	});
	requestTriggers.open('GET','save/triggers.json');
	requestTriggers.send();
}

// Get the triggers every 10 seconds, in case the file has been changed
setInterval(loadTriggers,10000);

async function readChatMessage(event){
	var data = event.detail;

	console.log(event);
	for(var i = 0, l = TRIGGERS.chat.length; i < l; i ++){
		// If chat message contains the phrase, run it; otherwise, continue over it. This will automatically support regex as a result.
		if(new RegExp(TRIGGERS.chat[i].contains,'i').test(data.message) === false) continue;
		
		// Check if is from a user
		if(TRIGGERS.chat[i].from !== '' && new RegExp('(?:^|,)' + data.display_name + '(?:$|,)','i').test(TRIGGERS.chat[i].from) === false) continue;
		
		// Check user type
		if(
			!(data.badges && data.badges.broadcaster) // Always allow the broadcaster in
		){
			if(TRIGGERS.chat[i].userType == 'sub' && data.subscriber == '0') continue;
			if(TRIGGERS.chat[i].userType == 'vip' && !(data.badges && data.badges.vip)) continue;
			if(TRIGGERS.chat[i].userType == 'mod' && data.mod == '0') continue;
		}
		
		// See if global cooldown has waited long enough
		if(hecklesLastUseGlobal[i]
			&& Date.now() - hecklesLastUseGlobal[i] < parseInt(TRIGGERS.chat[i].cooldown) * 1000
		){
			console.log('So far for global cooldown we\'ve waited ',Date.now() - hecklesLastUseGlobal[i],' milliseconds');
			continue;
		}
		
		// See if user cooldown has waited long enough
		if(hecklesLastUseUser[i] && hecklesLastUseUser[i][data.user_id]
			&& Date.now() - hecklesLastUseUser[i][data.user_id] < parseInt(TRIGGERS.chat[i].cooldown) * 1000
		){
			console.log('So far for user cooldown we\'ve waited ',Date.now() - hecklesLastUseUser[i][data.user_id],' milliseconds');
			continue;
		}
		
		runHeckle(TRIGGERS.chat[i].heckle);
		
		// Trigger cooldown values
		if(TRIGGERS.chat[i].cooldownType === 'global') hecklesLastUseGlobal[i] = Date.now();
		else if(TRIGGERS.chat[i].cooldownType === 'user'){
			if(!hecklesLastUseUser[i]){
				console.log('creating heckles user object');
				hecklesLastUseUser[i] = {};
			}
			hecklesLastUseUser[i][data.user_id] = Date.now();
		}
	}
}

function onRedemption(event){
	console.log(event);
	var message = event.detail;
	
	for(var i = 0, l = TRIGGERS.points.length; i < l; i ++){
		console.log(TRIGGERS.points[i]);
		if(TRIGGERS.points[i].title !== message.redemption.reward.title) continue;
		
		if(TRIGGERS.points[i].user_input !== '' && TRIGGERS.points[i].user_input !== message.redemption.user_input) continue;
		
		runHeckle(TRIGGERS.points[i].heckle);
	}
}

function onCheer(event){
	var message = event.detail;
	
	for(var i = 0, l = TRIGGERS.bits.length; i < l; i ++){
		console.log(TRIGGERS.bits[i]);
		
		if(TRIGGERS.bits[i].is_anonymous !== 'Any'
		&& String(TRIGGERS.bits[i].is_anonymous) !== String(message.is_anonymous)) continue;
		
		if(TRIGGERS.bits[i].bits_min > message.data.bits_used) continue;
		
		if(TRIGGERS.bits[i].bits_max < message.data.bits_used) continue;
		
		/*if(TRIGGERS.bits[i].chat_message_includes !== null
		&& TRIGGERS.bits[i].is_anonymous !== message.data.is_anonymous) continue;*/
		
		runHeckle(TRIGGERS.bits[i].heckle);
	}
}

function onSubscription(event){
	var message = event.detail;
	
	for(var i = 0, l = TRIGGERS.subscriptions.length; i < l; i ++){
		console.log(TRIGGERS.subscriptions[i]);
		
		if(TRIGGERS.subscriptions[i].sub_plan !== 'Any'
		&& TRIGGERS.subscriptions[i].sub_plan != message.sub_plan) continue;
		
		if(TRIGGERS.subscriptions[i].months_min > message.months) continue;
		
		if(TRIGGERS.subscriptions[i].months_max < message.months) continue;
		
		// Check the subscription context (sub, resub, subgift, anonsubgift, resubgift, anonresubgift), and ignore "re"; that doesn't seem important
		if(TRIGGERS.subscriptions[i].context !== 'Any'
		&& TRIGGERS.subscriptions[i].context !== message.context.replace('re','')) continue;
		
		/*if(TRIGGERS.subscriptions[i].message_includes !== null
		&& TRIGGERS.subscriptions[i].message_includes !== message.sub_message.message) continue;*/
		
		runHeckle(TRIGGERS.subscriptions[i].heckle);
	}
}

function runHeckle(heckle){
	// If the description for the reward doesn't include the catchphrase !hecklebyJoshPowlison it won't work
	//if(!/(?:^|\s)!hecklebyJoshPowlison(?:$|\s)/.test(message.data.redemption.reward.prompt)) return;
	
	// If it's right, create the heckle!
	console.log('HECKLE RUNNING',heckle);

	// Load the CSS animation for the heckle, if it hasn't already been loaded
	if(!document.getElementById(heckle)){
		var sheet = document.createElement('link');
		sheet.id = heckle;
		sheet.rel = 'stylesheet';
		sheet.href = 'save/assets/' + heckle + '/animation.css?' + new Date();
		document.head.appendChild(sheet);
	// If it's already been loaded, update it
	/// TODO: test to see if this breaks when multiple heckles are run at once
	// If it's already been loaded, update it based on the current timestamp (it's a local file, so we're not worrying about wasting server calls)
	} else {
		document.getElementById(heckle).href =  'save/assets/' + heckle + '/animation.css?' + new Date();
	}

	// Make the frame for the image
	var frameEl = new Image();
	frameEl.src = 'save/assets/' + heckle + '/image.png';
	frameEl.className = heckle;
	frameEl.style.animationName = heckle;
	
	// Load and play audio
	var request = new XMLHttpRequest();
	request.open('GET', 'save/assets/' + heckle + '/audio.mp3', true);
	request.responseType = 'arraybuffer';

	// Decode asynchronously
	request.onload = function(){
		AUDIO_CONTEXT.decodeAudioData(request.response, function(buffer) {
			var source = AUDIO_CONTEXT.createBufferSource();
			source.buffer = buffer;
			source.connect(AUDIO_CONTEXT.destination);
			source.start(0);
			document.getElementById('frame-holder').appendChild(frameEl);
			
			// Remove the frame once the sound has finished playing
			console.log('length get',buffer.duration);
			setTimeout(function(){
				frameEl.remove();
			},buffer.duration * 1000);
		}, function(error){console.log(error);});
	}
	request.send();
}

function interconnectTriggerHeckle(event){
	if(event.detail.source == 'viewerimpact' && event.detail.adminpanel)
		runHeckle(TRIGGERS.effects[event.detail.command]);
}

loadTriggers();
document.addEventListener('livestreamredemption',onRedemption);
document.addEventListener('livestreamcheer',onCheer);
document.addEventListener('livestreamsubscription',onSubscription);
document.addEventListener('livestreamchatmessage',readChatMessage);
document.addEventListener('interconnectmessage',interconnectTriggerHeckle);

</script>
</body>
</html>